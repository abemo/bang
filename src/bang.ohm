Bang {
  Program               = lineTerminator? Statement* lineTerminator?
  // TODO const can currently be used on existing vars
  // TODO statements can be stuck together on one line ex. `float = 5 str = "test"`
  Statement             = const? Var assignmentOp Exp                       -- varAssignment
                        | print "(" Exp ")"                                 -- print
                        | Exp
  Exp                   = Function | Lit | Var | MatchExp
  Block                 = "{" Statement* "}"
  Var                   = Var "[" Exp "]"                                   -- subscript
                        | Var "." id                                        -- select
                        | id
  Lit                   = nil       | Str       | Obj       | Num
                        | boolLit   
  
  // function stuff
  Function              = FunctionObj | Block
  FunctionObj           = "(" Params ")" arrow Block
  Params                = (Arg ("," Arg)*)?
  Arg                   = PositionalArg | KeywordArg
  PositionalArg         = ArgVal
  KeywordArg            = id "=" ArgVal
  ArgVal                = id | Lit
// TODO may need FunctionObj = Block
  arrow                 = "->"
  print                 = "print" // TODO: test for `x = 5`//`printx(x)`

  // objects
  Obj                   = "{" ObjField* "}"
  ObjField              = key ":" Exp
  key                   = ~keyword strLit

  // lists

  // strings
  Str                   = (Str | id) (plus (Str | id))+                     -- concatenation
                        | strLit | formattedStr
  strLit                = "'" singleStrChar* "'"
                        | "\"" doubleStrChar* "\""
  formattedStr          = "$'" formattedSubstr* "'"                         -- singleQuotes
                        | "$\"" formattedSubstr* "\""                       -- doubleQuotes
  formattedSubstr       = (strChar*)? "{" id "}"
  
  // special chars
  strChar               = singleStrChar | doubleStrChar
  singleStrChar         = ~("'" | "\\" | lineTerminator) any                -- nonEscaped
                        | "\\" escapeChar                                   -- escaped
                        | lineContinuation
  doubleStrChar         = ~("\"" | "\\" | lineTerminator) any               -- nonEscaped
                        | "\\" escapeChar                                   -- escaped
                        | lineContinuation
  escapeChar            = "'" | "\"" | "\\" | "n" | "t" | "r" | "u"
  char                  = ~(escapeChar | lineTerminator) any
  lineTerminator        = "\n" | "\r" ~"\n" | "\u2028" | "\u2029"
  lineContinuation      = "\\" lineTerminator

  // variables
  const                 = "const" ~idchar
  id                    = ~keyword (letter | "_") idchar*
  idchar                = letter | digit | "_"

  // booleans
  boolLit               = true | false
  true                  = "true" ~idchar
  false                 = "false" ~idchar

  // todo hex? "0x" hexNum
  // numbers
  Num                   = NumExp | Exponent | numLit
  NumExp                = (numLit | Var) arithmeticOp (numLit | Var)
  numLit                = minus? float
  float                 = digit+ ("." digit+)? (("E" | "e") ("+" | "-")? digit+)?
  Exponent              = (float | Var) power (numLit | Var)
  // TODO negative numbers

  // TODO bitwise ops?
  // TODO can currently do float += 1 even if float doesn't exist
  // operators
  arithmeticOp          = plus | minus | multiply | divide | modulus
  strOp                 = plus | multiply // TODO how to multiply strings?
  boolOp                = equality | inequality
  assignmentOp          = "=" | "+=" | "-=" | "*=" | "/=" | "%="
  and                   = "&&"
  or                    = "||"
  not                   = "!"
  equality              = "=="
  inequality            = "!="
  plus                  = "+"
  minus                 = "-"
  multiply              = "*"
  power                 = "**"
  divide                = "/"
  modulus               = "%"

  // switch statements
  MatchExp              = match id "{" MatchCase+ DefaultCase "}" lineTerminator?
  MatchCase             = case Lit ":" Statement lineTerminator?
  DefaultCase           = default ":" Statement lineTerminator?
  match                 = "match" ~idchar
  case                  = "case" ~idchar
  default               = "default"

  // ternaries

  // enums

  // other
  keyword               = const     | print     | boolLit     | match    
                        | nil
  nil                   = "nil" ~idchar

  // TODO: bools (0 and 1 also work), nums, and, or, not, equals, comments, break, nil, lists, objects


}